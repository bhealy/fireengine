<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Animated Flames GLB Export</title>
  <style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: #050508;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #eee;
    }
    #toolbar {
      position: absolute;
      z-index: 10;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 8px;
    }
    #toolbar button {
      padding: 6px 12px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-size: 13px;
      background: #e65100;
      color: white;
    }
    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
      display: block;
    }
  </style>

  <!-- Babylon core -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <!-- Serializers for GLB export -->
  <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
</head>
<body>
  <div id="toolbar">
    <button id="exportGlb">Download flames.glb</button>
  </div>
  <canvas id="renderCanvas"></canvas>

  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);

    const createScene = function () {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0.02, 0.02, 0.05, 1.0);

      // Camera
      const camera = new BABYLON.ArcRotateCamera(
        "camera",
        Math.PI / 3,
        Math.PI / 3,
        10,
        new BABYLON.Vector3(0, 1, 0),
        scene
      );
      camera.attachControl(canvas, true);

      // Light
      const light = new BABYLON.HemisphericLight(
        "light",
        new BABYLON.Vector3(0, 1, 0),
        scene
      );
      light.intensity = 0.8;

      // Ground (just for context; can be ignored when importing GLB)
      const ground = BABYLON.MeshBuilder.CreateGround("ground", {
        width: 10,
        height: 10
      }, scene);
      const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
      groundMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.12);
      ground.material = groundMat;

      // Flame root (so you can easily move the whole thing later)
      const flameRoot = new BABYLON.TransformNode("flameRoot", scene);
      flameRoot.position = new BABYLON.Vector3(0, 0, 0);

      // Main flame mesh: a tapered cylinder
      const flame = BABYLON.MeshBuilder.CreateCylinder("flame", {
        height: 2,
        diameterTop: 0.1,
        diameterBottom: 0.9,
        tessellation: 24
      }, scene);
      flame.position.y = 1.0;
      flame.parent = flameRoot;

      // Flame material (bright emissive orange)
      const flameMat = new BABYLON.StandardMaterial("flameMat", scene);
      flameMat.diffuseColor = new BABYLON.Color3(1.0, 0.5, 0.1);
      flameMat.emissiveColor = new BABYLON.Color3(1.0, 0.6, 0.2);
      flameMat.specularColor = new BABYLON.Color3(0.0, 0.0, 0.0);
      flameMat.alpha = 0.85;
      flame.material = flameMat;

      // Optional: add a smaller inner core for a hotter look
      const core = BABYLON.MeshBuilder.CreateCylinder("flameCore", {
        height: 1.6,
        diameterTop: 0.05,
        diameterBottom: 0.4,
        tessellation: 24
      }, scene);
      core.position.y = 1.1;
      core.parent = flameRoot;

      const coreMat = new BABYLON.StandardMaterial("coreMat", scene);
      coreMat.diffuseColor = new BABYLON.Color3(1.0, 0.9, 0.4);
      coreMat.emissiveColor = new BABYLON.Color3(1.0, 0.95, 0.5);
      coreMat.alpha = 0.9;
      core.material = coreMat;

      // --- ANIMATIONS ---
      const frameRate = 30;
      const totalFrames = frameRate * 2; // 2 seconds loop

      // Scale Y animation (flame height flicker)
      const scaleYAnim = new BABYLON.Animation(
        "flameScaleY",
        "scaling.y",
        frameRate,
        BABYLON.Animation.ANIMATIONTYPE_FLOAT,
        BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
      );

      const scaleYKeys = [
        { frame: 0,                  value: 0.9 },
        { frame: frameRate * 0.25,   value: 1.3 },
        { frame: frameRate * 0.5,    value: 1.0 },
        { frame: frameRate * 0.75,   value: 1.4 },
        { frame: totalFrames,        value: 0.9 }
      ];
      scaleYAnim.setKeys(scaleYKeys);

      // Scale X/Z animation (wobble)
      const scaleXZAnim = new BABYLON.Animation(
        "flameScaleXZ",
        "scaling.x",
        frameRate,
        BABYLON.Animation.ANIMATIONTYPE_FLOAT,
        BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
      );
      const scaleXZKeys = [
        { frame: 0,                  value: 1.0 },
        { frame: frameRate * 0.25,   value: 0.8 },
        { frame: frameRate * 0.5,    value: 1.1 },
        { frame: frameRate * 0.75,   value: 0.7 },
        { frame: totalFrames,        value: 1.0 }
      ];
      scaleXZAnim.setKeys(scaleXZKeys);

      // We'll mirror X to Z by using a second animation
      const scaleZAnim = new BABYLON.Animation(
        "flameScaleZ",
        "scaling.z",
        frameRate,
        BABYLON.Animation.ANIMATIONTYPE_FLOAT,
        BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
      );
      scaleZAnim.setKeys(scaleXZKeys);

      // Slight vertical bobbing
      const positionYAnim = new BABYLON.Animation(
        "flamePosY",
        "position.y",
        frameRate,
        BABYLON.Animation.ANIMATIONTYPE_FLOAT,
        BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
      );
      const posYKeys = [
        { frame: 0,                  value: 1.0 },
        { frame: frameRate * 0.25,   value: 1.1 },
        { frame: frameRate * 0.5,    value: 0.95 },
        { frame: frameRate * 0.75,   value: 1.15 },
        { frame: totalFrames,        value: 1.0 }
      ];
      positionYAnim.setKeys(posYKeys);

      // Attach animations to flameRoot (so the whole effect moves)
      flameRoot.animations = [
        scaleYAnim,
        scaleXZAnim,
        scaleZAnim,
        positionYAnim
      ];

      // Start the animation
      scene.beginAnimation(flameRoot, 0, totalFrames, true);

      // Small point light from the flame (visual only, not needed for GLB)
      const flameLight = new BABYLON.PointLight("flameLight", new BABYLON.Vector3(0, 1.5, 0), scene);
      flameLight.diffuse = new BABYLON.Color3(1.0, 0.7, 0.3);
      flameLight.intensity = 6;
      flameLight.range = 6;

      // Flicker the light intensity a bit
      scene.registerBeforeRender(() => {
        const t = performance.now() * 0.005;
        flameLight.intensity = 5.5 + Math.sin(t * 1.7) * 0.8 + Math.sin(t * 2.3) * 0.5;
      });

      return scene;
    };

    const scene = createScene();

    engine.runRenderLoop(function () {
      scene.render();
    });

    window.addEventListener("resize", function () {
      engine.resize();
    });

    // EXPORT GLB BUTTON
    document.getElementById("exportGlb").addEventListener("click", function () {
      // Export the whole scene (camera/ground included). If you only want the flame,
      // you can pass an array with just flameRoot in GLTF2Export.GLBAsync.
      BABYLON.GLTF2Export.GLBAsync(scene, "flames").then(function (glb) {
        glb.downloadFiles(); // triggers a download of flames.glb
      }).catch(function (err) {
        console.error("GLB export error:", err);
      });
    });
  </script>
</body>
</html>
